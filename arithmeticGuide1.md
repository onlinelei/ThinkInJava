
# 算法

## 1 数据结构

### 1.1 数组

### 1.2 连表

### 1.3 树

树是一种非线性的数据结构，相对于线性的数据结构(链表、数组)而言，树的平均运行时间更短(往往与树相关的排序时间复杂度都不会高)，但是在编程的世界中，我们一般把树**“倒”**过来看，这样容易我们分析。一般的树是有很多很多个分支的，分支下又有很多很多个分支，如果在程序中研究这个会非常麻烦。因为本来树就是非线性的，而我们计算机的内存是线性存储的，太过复杂的话我们无法设计出来。因此，我们一般研究常用二叉树，也就是每个节点有两个分支的树结构。

树结构包含二叉树、二叉查找树、平衡二叉树、平衡查找树之AVL树、平衡二叉树之红黑树、B树、B+树、B*树、Trie树、等。

#### 1.3.1 二叉树

* 二叉树：二叉树的每个结点至多只有二棵子树(不存在度大于2的结点)，二叉树的子树有左右之分，次序不能颠倒。二叉树的第i层至多有2的i-1次方个结点；深度为k的二叉树至多有2的k-1次方个结点。
* 满二叉树：除最后一层无任何子节点外，每一层上的所有结点都有两个子结点。也可以这样理解，除叶子结点外的所有结点均有两个子结点。节点数达到最大值，所有叶子结点必须在同一层上。
* 完全二叉树：若设二叉树的深度为h，除第 h 层外，其它各层 (1～(h-1)层) 的结点数都达到最大个数，第h层所有的结点都连续集中在最左边，这就是完全二叉树。

#### 1.3.2 二叉查找树

二叉查找树，又称为是二叉排序树（Binary Sort Tree）或二叉搜索树。二叉查找树具有以下性质：

1. 若左子树不空，则左子树上所有结点的值均小于它的根结点的值；
2. 若右子树不空，则右子树上所有结点的值均大于或等于它的根结点的值；
3. 左、右子树也分别为二叉排序树；
4. 没有值相等的节点。
5. 二叉查找树的性质：对二叉查找树进行中序遍历，即可得到有序的数列。

#### 1.3.2 平衡二叉树

二叉查找树的时间复杂度：它和二分查找一样，插入和查找的时间复杂度均为O(logn)，在某些极端的情况下（如在插入的序列是有序的时），二叉搜索树将退化成近似链或链，此时，其操作的时间复杂度将退化成线性的，时间复杂度将退化为O(n)。原因在于插入和删除元素的时候，树没有保持平衡。

平衡二叉树定义：平衡二叉树（Balanced Binary Tree）又被称为AVL树（有别于AVL算法），且具有以下性质：它是一 棵空树或它的左右两个子树的高度差的绝对值不超过1，并且左右两个子树都是一棵平衡二叉树。平衡二叉树的常用算法有红黑树、AVL树等。在平衡二叉搜索树中，我们可以看到，其高度一般都良好地维持在O(log2n)，大大降低了操作的时间复杂度。

#### 1.3.3 平衡查找树之AVL树

AVL树定义：AVL树是最先发明的**自平衡二叉查找树**。AVL树得名于它的发明者 G.M. Adelson-Velsky 和 E.M. Landis，他们在 1962 年的论文 "An algorithm for the organization of information" 中发表了它。在AVL中任何节点的两个儿子子树的高度最大差别为1，所以它也被称为高度平衡树，n个结点的AVL树最大深度约1.44log2n。查找、插入和删除在平均和最坏情况下都是O(logn)。增加和删除可能需要通过一次或多次树旋转来重新平衡这个树。这个方案很好的解决了二叉查找树退化成链表的问题，把插入，查找，删除的时间复杂度最好情况和最坏情况都维持在O(logN)。但是频繁旋转会使插入和删除牺牲掉O(logN)左右的时间，不过相对二叉查找树来说，时间上稳定了很多。

#### 1.3.4 平衡二叉树之红黑树

红黑树的定义：红黑树是一种自平衡二叉查找树，是在计算机科学中用到的一种数据结构，典型的用途是实现关联数组。它是在1972年由鲁道夫·贝尔发明的，称之为"对称二叉B树"，它现代的名字是在 Leo J. Guibas 和 Robert Sedgewick 于1978年写的一篇论文中获得的。它是复杂的，但它的操作有着良好的最坏情况运行时间，并且在实践中是高效的: 它可以在O(logn)时间内做查找，插入和删除，这里的n是树中元素的数目。

红黑树的性质：红黑树是每个节点都带有颜色属性的二叉查找树，颜色为红色或黑色。在二叉查找树强制的一般要求以外，对于任何有效的红黑树我们增加了如下的额外要求:

* 节点是红色或黑色。
* 根是黑色。
* 所有叶子都是黑色（叶子是NIL节点）。
* 每个红色节点必须有两个黑色的子节点。(从每个叶子到根的所有路径上不能有两个连续的红色节点。)
* 从任一节点到其每个叶子的所有简单路径都包含相同数目的黑色节点。

<img src="https://gitee.com/suqianlei/Pic-Go-Repository/raw/master/img/20200618175807.png" alt="An example of a red-black tree" style="zoom:67%;" />

#### 1.3.5 B树

B树的定义：B树（B-tree）是一种树状数据结构，能够用来存储排序后的数据，它也是平衡树，但是它不是二叉树。这种数据结构能够让查找数据、循序存取、插入数据及删除的动作，都在对数时间内完成。B树，概括来说是一个一般化的二叉查找树，可以拥有多于2个子节点。与自平衡二叉查找树不同，B-树为系统最优化大块数据的读和写操作。B-tree算法减少定位记录时所经历的中间过程，从而加快存取速度。这种数据结构常被应用在数据库和文件系统的实作上。B树作为一种多路搜索树，它有以下性质：

* 定义任意非叶子结点最多只有M个儿子；且M>2；

* 根结点的儿子数为[2, M]；

* 除根结点以外的非叶子结点的儿子数为[M/2, M]；

* 每个结点存放至少M/2-1（取上整）和至多M-1个关键字；（至少2个关键字）

* 叶子结点的关键字个数=指向儿子的指针个数-1；

* 叶子结点的关键字：K[1], K[2], …, K[M-1]；且K[i] < K[i+1]；

* 叶子结点的指针：P[1], P[2], …, P[M]；其中P[1]指向关键字小于K[1]的子树，P[M]指向关键字大于K[M-1]的子树，其它P[i]指向关键字属于(K[i-1], K[i])的子树；

* 有叶子结点位于同一层；

![img](https://gitee.com/suqianlei/Pic-Go-Repository/raw/master/img/20200618182052.gif)


在B树中查找给定关键字的方法是，首先把根结点取来，在根结点所包含的关键字K1,…,Kn查找给定的关键字（可用顺序查找或二分查找法），若找到等于给定值的关键字，则查找成功；否则，一定可以确定要查找的关键字在Ki与Ki+1之间，Pi为指向子树根节点的指针，此时取指针Pi所指的结点继续查找，直至找到，或指针Pi为空时查找失败。

#### 1.3.6 B+树

B+树是B树的变体，也是一种多路搜索树， 其定义基本与B-树相同，除了以下特性：

* 非叶子结点的子树指针与关键字个数相同；
* 非叶子结点的子树指针P[i]，指向关键字值属于[K[i], K[i+1])的子树（B-树是开区间）；
* 为所有叶子结点增加一个链指针；
* 所有关键字都在叶子结点出现；

B+树的性质：

* 所有关键字都出现在叶子结点的链表中（稠密索引），且链表中的关键字恰好是有序的；
* 不可能在非叶子结点命中；
* 非叶子结点相当于是叶子结点的索引（稀疏索引），叶子结点相当于是存储（关键字）数据的数据层；
* 更适合文件索引系统。

![img](https://gitee.com/suqianlei/Pic-Go-Repository/raw/master/img/20200618183522.gif)

#### 1.3.7 B*树

B*树是B+树的变体，在B+树的非根和非叶子结点再增加指向兄弟的指针，将结点的最低利用率从1/2提高到2/3。B*树定义了非叶子结点关键字个数至少为(2/3)*M，即块的最低使用率为2/3（代替B+树的1/2）；
B+树的分裂：当一个结点满时，分配一个新的结点，并将原结点中1/2的数据复制到新结点，最后在父结点中增加新结点的指针；B+树的分裂只影响原结点和父结点，而不会影响兄弟结点，所以它不需要指向兄弟的指针；
B*树的分裂：当一个结点满时，如果它的下一个兄弟结点未满，那么将一部分数据移到兄弟结点中，再在原结点插入关键字，最后修改父结点中兄弟结点的关键字（因为兄弟结点的关键字范围改变了）；如果兄弟也满了，则在原结点与兄弟结点之间增加新结点，并各复制1/3的数据到新结点，最后在父结点增加新结点的指针；
所以，B*树分配新结点的概率比B+树要低，空间使用率更高。

#### 1.3.7 Trie树

### 1.4 图


## 2 排序算法

### 2.1 双轴快速排序（Dual-Pivot QuickSort）

DualPivotQuicksort，该排序算法是不稳定的，即：相等的两个元素在排序前后的相对位置可能会发生变化

### 2.2 TimSort

思想上也是一种归并和二分插入排序（binarySort）结合的优化排序算法，简单说它的思路是查找数据集中已经排好序的分区（这里叫 run），然后合并这些分区来达到排序的目的。

### 2.3 parallelSort

简单的说实现方法就是将数组拆分成多个子数组，多线程进行排序，然后归并
